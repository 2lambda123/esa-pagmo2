 <!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Multi-objective optimization utilities &#8212; pagmo 2.11 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pagmo.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/logo_favico.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Constrained optimization utilities" href="py_con_utils.html" />
    <link rel="prev" title="Generic optimization utilities" href="py_generic_utils.html" />
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto|Comfortaa|Space+Mono"> 
  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html"><span><img src="../../../_static/logo_small_html.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>2.11</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../index.html">Home</a></li>
                <li><a href="../../../install.html">Install</a></li>
                <li><a href="../../../quickstart.html">Quickstart</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">All <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../install.html#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../install.html#python">Python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick start</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../quickstart.html#c">C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../quickstart.html#python">Python</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../algorithm_list.html">List of algorithms (UDAs) available in pagmo/pygmo</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../algorithm_list.html#heuristic-global-optimization">Heuristic Global Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algorithm_list.html#local-optimization">Local optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../algorithm_list.html#meta-algorithms">Meta-algorithms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../problem_list.html">List of problems (UDPs) available in pagmo/pygmo</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../problem_list.html#scalable-problems">Scalable problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../problem_list.html#problem-suites">Problem suites</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../problem_list.html#meta-problems">Meta-problems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../island_list.html">List of islands (UDIs) available in pagmo/pygmo</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../cpp/cpp_docs.html">C++ Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../cpp/cpp_docs.html#core-classes">Core classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cpp/cpp_docs.html#implemented-algorithms">Implemented algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cpp/cpp_docs.html#implemented-problems">Implemented problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cpp/cpp_docs.html#implemented-islands">Implemented islands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cpp/cpp_docs.html#implemented-batch-evaluators">Implemented batch evaluators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cpp/cpp_docs.html#utilities">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cpp/cpp_docs.html#miscellanea">Miscellanea</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../cpp/tutorials/cpp_tut.html">C++ tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../cpp/tutorials/cpp_tut.html#basics">Basics</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../python_docs.html">Python Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../python_docs.html#core-classes">Core classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python_docs.html#implemented-problems-algorithms-islands-and-bfes">Implemented problems, algorithms, islands and bfes</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../python_docs.html#utilities">Utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/python_tut.html">Python tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/python_tut.html#basics">Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/python_tut.html#coding-your-own-problem-udp">Coding your own problem (UDP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/python_tut.html#meta-problems">Meta-problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/python_tut.html#coding-your-own-island-udi">Coding your own island (UDI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/python_tut.html#local-optimization">Local optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/python_tut.html#multi-objective-optimization">Multi-objective optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/python_tut.html#hypervolumes">Hypervolumes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/python_tut.html#advanced-examples">Advanced Examples</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../credits.html#main-developers">Main developers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#unreleased">2.11 (unreleased)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id1">2.10 (2019-01-02)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id4">2.9 (2018-08-31)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id8">2.8 (2018-07-12)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id12">2.7 (2018-04-13)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id15">2.6 (2017-11-18)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id17">2.5 (2017-11-12)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id19">2.4 (2017-06-09)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id23">2.3 (2017-05-19)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../changelog.html#id26">2.2 (2017-05-12)</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">This Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Multi-objective optimization utilities</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="multi-objective-optimization-utilities">
<span id="py-mo-utils"></span><h1>Multi-objective optimization utilities<a class="headerlink" href="#multi-objective-optimization-utilities" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="pygmo.fast_non_dominated_sorting">
<code class="sig-prename descclassname">pygmo.</code><code class="sig-name descname">fast_non_dominated_sorting</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.fast_non_dominated_sorting" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the fast non dominated sorting algorithm on the input <em>points</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> – the input points</p>
</dd>
<dt class="field-even">Type points</dt>
<dd class="field-even"><p>2d-array-like object</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if <em>points</em> is malformed</p>
</dd>
<dt class="field-even">Raises TypeError</dt>
<dd class="field-even"><p>if <em>points</em> cannot be converted to a vector of vector floats</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>(<em>ndf</em>, <em>dl</em>, <em>dc</em>, <em>ndr</em>), where:</p>
<ul class="simple">
<li><p><em>ndf</em> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of 1D NumPy int array): the non dominated fronts</p></li>
<li><p><em>dl</em> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of 1D NumPy int array): the domination list</p></li>
<li><p><em>dc</em> (1D NumPy int array): the domination count</p></li>
<li><p><em>ndr</em> (1D NumPy int array): the non domination ranks</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">tuple</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygmo</span> <span class="k">as</span> <span class="nn">pg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ndf</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">ndr</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">fast_non_dominated_sorting</span><span class="p">(</span><span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mf">2.3</span><span class="p">,</span><span class="o">-</span><span class="mf">0.2</span><span class="p">],[</span><span class="mf">1.1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.12</span><span class="p">],[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.12</span><span class="p">],[</span><span class="o">-</span><span class="mf">1.1</span><span class="p">,</span><span class="o">-</span><span class="mf">1.1</span><span class="p">]])</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="pygmo.nadir">
<code class="sig-prename descclassname">pygmo.</code><code class="sig-name descname">nadir</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.nadir" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the nadir point of a set of points, i.e objective vectors. The nadir is that point that has the maximum
value of the objective function in the points of the non-dominated front.</p>
<p>Complexity is <span class="math notranslate nohighlight">\(\mathcal{O}(MN^2)\)</span> where <span class="math notranslate nohighlight">\(M\)</span> is the number of objectives and <span class="math notranslate nohighlight">\(N\)</span> is the number of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> – the input points</p>
</dd>
<dt class="field-even">Type points</dt>
<dd class="field-even"><p>2d-array-like object</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if <em>points</em> is malformed</p>
</dd>
<dt class="field-even">Raises TypeError</dt>
<dd class="field-even"><p>if <em>points</em> cannot be converted to a vector of vector floats</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the nadir point</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="pygmo.ideal">
<code class="sig-prename descclassname">pygmo.</code><code class="sig-name descname">ideal</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.ideal" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the ideal point of a set of points, i.e objective vectors. The ideal point is that point that has, in each
component, the minimum value of the objective functions of the input points.</p>
<p>Complexity is <span class="math notranslate nohighlight">\(\mathcal{O}(MN)\)</span> where <span class="math notranslate nohighlight">\(M\)</span> is the number of objectives and <span class="math notranslate nohighlight">\(N\)</span> is the number of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> – the input points</p>
</dd>
<dt class="field-even">Type points</dt>
<dd class="field-even"><p>2d-array-like object</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if <em>points</em> is malformed</p>
</dd>
<dt class="field-even">Raises TypeError</dt>
<dd class="field-even"><p>if <em>points</em> cannot be converted to a vector of vector floats</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the ideal point</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="pygmo.pareto_dominance">
<code class="sig-prename descclassname">pygmo.</code><code class="sig-name descname">pareto_dominance</code><span class="sig-paren">(</span><em class="sig-param">obj1</em>, <em class="sig-param">obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.pareto_dominance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>obj1</em> Pareto dominates <em>obj2</em>, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise. Minimization
is assumed.</p>
<p>Each pair of corresponding elements in  <em>obj1</em> and <em>obj2</em> is compared: if all
elements in <em>obj1</em> are less or equal to the corresponding element in <em>obj2</em>,
but at least one is different, <code class="docutils literal notranslate"><span class="pre">True</span></code> will be returned. Otherwise, <code class="docutils literal notranslate"><span class="pre">False</span></code> will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj1</strong> – the first list of objectives</p></li>
<li><p><strong>obj2</strong> – the second list of objectives</p></li>
</ul>
</dd>
<dt class="field-even">Type obj1</dt>
<dd class="field-even"><p>array-like object</p>
</dd>
<dt class="field-odd">Type obj2</dt>
<dd class="field-odd"><p>array-like object</p>
</dd>
<dt class="field-even">Raises ValueError</dt>
<dd class="field-even"><p>if the dimensions of <em>obj1</em> and <em>obj2</em> are different</p>
</dd>
<dt class="field-odd">Raises TypeError</dt>
<dd class="field-odd"><p>if <em>obj1</em> or <em>obj2</em> cannot be converted to a vector of vector floats</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>obj1</em> is dominating <em>obj2</em>, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
<dt class="field-odd">Rtype</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygmo</span> <span class="k">as</span> <span class="nn">pg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pg</span><span class="o">.</span><span class="n">pareto_dominance</span><span class="p">(</span><span class="n">obj1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">obj2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="pygmo.non_dominated_front_2d">
<code class="sig-prename descclassname">pygmo.</code><code class="sig-name descname">non_dominated_front_2d</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.non_dominated_front_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the non dominated front of a set of two dimensional objectives. Complexity is <span class="math notranslate nohighlight">\(\mathcal{O}(N \log N)\)</span>
and is thus lower than the complexity of calling <a class="reference internal" href="#pygmo.fast_non_dominated_sorting" title="pygmo.fast_non_dominated_sorting"><code class="xref py py-func docutils literal notranslate"><span class="pre">fast_non_dominated_sorting()</span></code></a></p>
<p>See: Jensen, Mikkel T. “Reducing the run-time complexity of multiobjective EAs: The NSGA-II and other algorithms.”
IEEE Transactions on Evolutionary Computation 7.5 (2003): 503-515.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> – the input points</p>
</dd>
<dt class="field-even">Type points</dt>
<dd class="field-even"><p>2d-array-like object</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if <em>points</em> contain anything else than 2 dimensional objectives</p>
</dd>
<dt class="field-even">Raises TypeError</dt>
<dd class="field-even"><p>if <em>points</em> cannot be converted to a vector of vector floats</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the non dominated fronts</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>(<code class="docutils literal notranslate"><span class="pre">list</span></code> of 1D NumPy int array)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygmo</span> <span class="k">as</span> <span class="nn">pg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pg</span><span class="o">.</span><span class="n">non_dominated_front_2d</span><span class="p">(</span><span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="go">array([0, 1, 5, 4], dtype=uint64)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="pygmo.sort_population_mo">
<code class="sig-prename descclassname">pygmo.</code><code class="sig-name descname">sort_population_mo</code><span class="sig-paren">(</span><em class="sig-param">points</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.sort_population_mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts a multi-objective, unconstrained,  population (intended here as a 2D array-like
containing objective vectors) with respect to the following strict ordering:</p>
<ul class="simple">
<li><dl class="simple">
<dt><span class="math notranslate nohighlight">\(f_1 \prec f_2\)</span> if the non domination ranks are such that <span class="math notranslate nohighlight">\(i_1 &lt; i_2\)</span>. In case <span class="math notranslate nohighlight">\(i_1 = i_2\)</span>,</dt><dd><p>then <span class="math notranslate nohighlight">\(f_1 \prec f_2\)</span> if the crowding distances are such that <span class="math notranslate nohighlight">\(d_1 &gt; d_2\)</span>.</p>
</dd>
</dl>
</li>
</ul>
<p>Complexity is <span class="math notranslate nohighlight">\(\mathcal{O}(M N^2)\)</span> where <span class="math notranslate nohighlight">\(M\)</span> is the size of the objective vector and <span class="math notranslate nohighlight">\(N\)</span> is the number of individuals.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will also work for single objective optimization, i.e. with objective vector
of size 1, in which case, though, it is more efficient to sort using python built-in sorting methods.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> – the input objective vectors</p>
</dd>
<dt class="field-even">Type points</dt>
<dd class="field-even"><p>2d-array-like object</p>
</dd>
<dt class="field-odd">Raises unspecified</dt>
<dd class="field-odd"><p>all exceptions thrown by pagmo::fast_non_dominated_sorting and pagmo::crowding_distance</p>
</dd>
<dt class="field-even">Raises TypeError</dt>
<dd class="field-even"><p>if <em>points</em> cannot be converted to a vector of vector floats</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the indexes of the sorted objectives vectors.</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>(<code class="docutils literal notranslate"><span class="pre">list</span></code> of 1D NumPy int array)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygmo</span> <span class="k">as</span> <span class="nn">pg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pop</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">population</span><span class="p">(</span><span class="n">prob</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">dtlz</span><span class="p">(</span><span class="n">prob_id</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fdim</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pg</span><span class="o">.</span><span class="n">sort_population_mo</span><span class="p">(</span><span class="n">points</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">get_f</span><span class="p">())</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">array([ 4,  7, 14, 15, 16, 18,  9, 13,  5,  3,  6,  2, 12,  0,  1, 19, 17, 8, 10, 11], dtype=uint64)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="pygmo.select_best_N_mo">
<code class="sig-prename descclassname">pygmo.</code><code class="sig-name descname">select_best_N_mo</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">N</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.select_best_N_mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns (unordered) the best N individuals out of a multi-objective, unconstrained population, (intended here
as a 2D array-like containing objective vectors). The strict ordering used is the same as that defined
in <a class="reference internal" href="#pygmo.sort_population_mo" title="pygmo.sort_population_mo"><code class="xref py py-func docutils literal notranslate"><span class="pre">sort_population_mo()</span></code></a></p>
<p>Complexity is <span class="math notranslate nohighlight">\(\mathcal{O}(M N^2)\)</span> where <span class="math notranslate nohighlight">\(M\)</span> is the number of objectives and <span class="math notranslate nohighlight">\(N\)</span> is the number of individuals.</p>
<p>While the complexity is the same as that of <a class="reference internal" href="#pygmo.sort_population_mo" title="pygmo.sort_population_mo"><code class="xref py py-func docutils literal notranslate"><span class="pre">sort_population_mo()</span></code></a>, this function is to be preferred when
possible in that it avoids to compute the crowidng distance for all individuals and only computes it for the last
non-dominated front containing individuals included in the best N.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> – the input objective vectors</p></li>
<li><p><strong>N</strong> – The size of the returned list of bests.</p></li>
</ul>
</dd>
<dt class="field-even">Type points</dt>
<dd class="field-even"><p>2d-array-like object</p>
</dd>
<dt class="field-odd">Type N</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Raises unspecified</dt>
<dd class="field-even"><p>all exceptions thrown by <a class="reference internal" href="../../cpp/utils/multi_objective.html#_CPPv4N5pagmo26fast_non_dominated_sortingERKNSt6vectorI13vector_doubleEE" title="pagmo::fast_non_dominated_sorting"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">pagmo::fast_non_dominated_sorting()</span></code></a> and <a class="reference internal" href="../../cpp/utils/multi_objective.html#_CPPv4N5pagmo17crowding_distanceERKNSt6vectorI13vector_doubleEE" title="pagmo::crowding_distance"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">pagmo::crowding_distance()</span></code></a></p>
</dd>
<dt class="field-odd">Raises TypeError</dt>
<dd class="field-odd"><p>if <em>points</em> cannot be converted to a vector of vector floats</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the indexes of the <em>N</em> best objectives vectors.</p>
</dd>
<dt class="field-odd">Rtype</dt>
<dd class="field-odd"><p>(<code class="docutils literal notranslate"><span class="pre">list</span></code> of 1D NumPy int array)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygmo</span> <span class="k">as</span> <span class="nn">pg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pop</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">population</span><span class="p">(</span><span class="n">prob</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">dtlz</span><span class="p">(</span><span class="n">prob_id</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fdim</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pg</span><span class="o">.</span><span class="n">select_best_N_mo</span><span class="p">(</span><span class="n">points</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">get_f</span><span class="p">(),</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">13</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">array([ 2,  3,  4,  5,  6,  7,  9, 12, 13, 14, 15, 16, 18], dtype=uint64)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="pygmo.decompose_objectives">
<code class="sig-prename descclassname">pygmo.</code><code class="sig-name descname">decompose_objectives</code><span class="sig-paren">(</span><em class="sig-param">objs</em>, <em class="sig-param">weights</em>, <em class="sig-param">ref_point</em>, <em class="sig-param">method</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.decompose_objectives" title="Permalink to this definition">¶</a></dt>
<dd><p>Decomposes a vector of objectives.</p>
<p>A vector of objectives is reduced to one only objective using a decomposition technique.</p>
<p>Three different possibilities for <em>method</em> are here made available:</p>
<ul class="simple">
<li><p>weighted decomposition,</p></li>
<li><p>Tchebycheff decomposition,</p></li>
<li><p>boundary interception method (with penalty constraint).</p></li>
</ul>
<p>In the case of <span class="math notranslate nohighlight">\(n\)</span> objectives, we indicate with: <span class="math notranslate nohighlight">\(\mathbf f(\mathbf x) = [f_1(\mathbf x), \ldots,
f_n(\mathbf x)]\)</span> the vector containing the original multiple objectives, with: <span class="math notranslate nohighlight">\(\boldsymbol \lambda =
(\lambda_1, \ldots, \lambda_n)\)</span> an <span class="math notranslate nohighlight">\(n\)</span>-dimensional weight vector and with: <span class="math notranslate nohighlight">\(\mathbf z^* = (z^*_1, \ldots,
z^*_n)\)</span> an <span class="math notranslate nohighlight">\(n\)</span>-dimensional reference point. We also ussume <span class="math notranslate nohighlight">\(\lambda_i &gt; 0, \forall i=1..n\)</span> and <span class="math notranslate nohighlight">\(\sum_i
\lambda_i = 1\)</span>.</p>
<p>The resulting single objective is thus defined as:</p>
<ul class="simple">
<li><p>weighted decomposition: <span class="math notranslate nohighlight">\(f_d(\mathbf x) = \boldsymbol \lambda \cdot \mathbf f\)</span></p></li>
<li><p>Tchebycheff decomposition: <span class="math notranslate nohighlight">\(f_d(\mathbf x) = \max_{1 \leq i \leq m} \lambda_i \vert f_i(\mathbf x) - z^*_i \vert\)</span></p></li>
<li><p>boundary interception method (with penalty constraint): <span class="math notranslate nohighlight">\(f_d(\mathbf x) = d_1 + \theta d_2\)</span></p></li>
</ul>
<p>where <span class="math notranslate nohighlight">\(d_1 = (\mathbf f - \mathbf z^*) \cdot \hat {\mathbf i}_{\lambda}\)</span> ,
<span class="math notranslate nohighlight">\(d_2 = \vert (\mathbf f - \mathbf z^*) - d_1 \hat {\mathbf i}_{\lambda})\vert\)</span> , and
<span class="math notranslate nohighlight">\(\hat {\mathbf i}_{\lambda} = \frac{\boldsymbol \lambda}{\vert \boldsymbol \lambda \vert}\)</span></p>
<p>Note that while <cite>ref_point</cite> is required, it does not impact the calculation for the <cite>weighted</cite> method as shown above.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>objs</strong> – the objective vectors</p></li>
<li><p><strong>weights</strong> – the weights <span class="math notranslate nohighlight">\(\boldsymbol \lambda\)</span></p></li>
<li><p><strong>ref_point</strong> – the reference point <span class="math notranslate nohighlight">\(\mathbf z^*\)</span> . It is not used if <em>method</em> is <code class="docutils literal notranslate"><span class="pre">&quot;weighted&quot;</span></code></p></li>
<li><p><strong>method</strong> – the decomposition method: one of <code class="docutils literal notranslate"><span class="pre">&quot;weighted&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;tchebycheff&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;bi&quot;</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Type objs</dt>
<dd class="field-even"><p>array-like object</p>
</dd>
<dt class="field-odd">Type weights</dt>
<dd class="field-odd"><p>array-like object</p>
</dd>
<dt class="field-even">Type ref_point</dt>
<dd class="field-even"><p>array-like object</p>
</dd>
<dt class="field-odd">Type method</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">string</span></code></p>
</dd>
<dt class="field-even">Raises ValueError</dt>
<dd class="field-even"><p>if <em>objs</em>, <em>weight</em> and <em>ref_point</em> have different sizes or if <em>method</em> is not one of <code class="docutils literal notranslate"><span class="pre">&quot;weighted&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;tchebycheff&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;bi&quot;</span></code>.</p>
</dd>
<dt class="field-odd">Raises TypeError</dt>
<dd class="field-odd"><p>if <em>weights</em> or <em>ref_point</em> or <em>objs</em> cannot be converted to a vector of floats.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a one dimensional array containing the decomposed objective.</p>
</dd>
<dt class="field-odd">Rtype</dt>
<dd class="field-odd"><p>1D NumPy float array</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygmo</span> <span class="k">as</span> <span class="nn">pg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pg</span><span class="o">.</span><span class="n">decompose_objectives</span><span class="p">(</span><span class="n">objs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.8</span><span class="p">],</span> <span class="n">ref_point</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;weighted&quot;</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">array([ 2.7])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pg</span><span class="o">.</span><span class="n">decompose_objectives</span><span class="p">(</span><span class="n">objs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.8</span><span class="p">],</span> <span class="n">ref_point</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;weighted&quot;</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">array([ 2.7])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pg</span><span class="o">.</span><span class="n">decompose_objectives</span><span class="p">(</span><span class="n">objs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.8</span><span class="p">],</span> <span class="n">ref_point</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;tchebycheff&quot;</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">array([ 1.6])</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="pygmo.decomposition_weights">
<code class="sig-prename descclassname">pygmo.</code><code class="sig-name descname">decomposition_weights</code><span class="sig-paren">(</span><em class="sig-param">n_f</em>, <em class="sig-param">n_w</em>, <em class="sig-param">method</em>, <em class="sig-param">seed</em><span class="sig-paren">)</span><a class="headerlink" href="#pygmo.decomposition_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the requested number of weight vectors to be used to decompose a multi-objective problem. Three methods are available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;grid&quot;</span></code> generates weights on an uniform grid. This method may only be used when the number of requested weights to be genrated is such that a uniform grid is indeed possible.
In two dimensions this is always the case, but in larger dimensions uniform grids are possible only in special cases</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;random&quot;</span></code> generates weights randomly distributing them uniformly on the simplex (weights are such that <span class="math notranslate nohighlight">\(\sum_i \lambda_i = 1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;low</span> <span class="pre">discrepancy&quot;</span></code> generates weights using a low-discrepancy sequence to, eventually, obtain a better coverage of the Pareto front. Halton sequence is used since
low dimensionalities are expected in the number of objectives (i.e. less than 20), hence Halton sequence is deemed as appropriate.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All methods are guaranteed to generate weights on the simplex (<span class="math notranslate nohighlight">\(\sum_i \lambda_i = 1\)</span>). All weight generation methods are guaranteed
to generate the canonical weights [1,0,0,…], [0,1,0,..], … first.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_f</strong> – the objective vectors</p></li>
<li><p><strong>n_w</strong> – the weights <span class="math notranslate nohighlight">\(\boldsymbol \lambda\)</span></p></li>
<li><p><strong>method</strong> – the reference point <span class="math notranslate nohighlight">\(\mathbf z^*\)</span>. It is not used if <em>method</em> is <code class="docutils literal notranslate"><span class="pre">&quot;weighted&quot;</span></code></p></li>
<li><p><strong>seed</strong> – the decomposition method: one of <code class="docutils literal notranslate"><span class="pre">&quot;weighted&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;tchebycheff&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;bi&quot;</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Type n_f</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-odd">Type n_w</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Type method</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">string</span></code></p>
</dd>
<dt class="field-odd">Type seed</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Raises OverflowError</dt>
<dd class="field-even"><p>if <em>n_f</em>, <em>n_w</em> or <em>seed</em> are negative or greater than an implementation-defined value</p>
</dd>
<dt class="field-odd">Raises ValueError</dt>
<dd class="field-odd"><p>if <em>n_f</em> and <em>n_w</em> are not compatible with the selected weight generation method or if <em>method</em> is not</p>
</dd>
<dt class="field-even">Raises one of “grid”, “random” or “low discrepancy”<code class="docutils literal notranslate"><span class="pre">&quot;grid&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;random&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;low</span> <span class="pre">discrepancy&quot;</span></code></dt>
<dd class="field-even"><p></p></dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the weights</p>
</dd>
<dt class="field-even">Rtype</dt>
<dd class="field-even"><p>1D NumPy float array</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pygmo</span> <span class="k">as</span> <span class="nn">pg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pg</span><span class="o">.</span><span class="n">decomposition_weights</span><span class="p">(</span><span class="n">n_f</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_w</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;low discrepancy&quot;</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">33</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">array([[ 1.   ,  0.   ],</span>
<span class="go">       [ 0.   ,  1.   ],</span>
<span class="go">       [ 0.25 ,  0.75 ],</span>
<span class="go">       [ 0.75 ,  0.25 ],</span>
<span class="go">       [ 0.125,  0.875],</span>
<span class="go">       [ 0.625,  0.375]])</span>
</pre></div>
</div>
</dd></dl>

</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017-2018, pagmo development team.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>
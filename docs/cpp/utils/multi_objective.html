 

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Multi-objective optimization utilities &mdash; pagmo 2.16.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/logo_favico.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Constrained optimization utilities" href="constrained.html" />
    <link rel="prev" title="Best selection policy" href="../s_policies/select_best.html" />
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto|Comfortaa|Space+Mono"> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> pagmo
          

          
          </a>

          
            
            
              <div class="version">
                2.16.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Capabilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/cpp_tut.html">C++ tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../cpp_docs.html">C++ API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#core-classes">Core classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#implemented-algorithms">Implemented algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#implemented-problems">Implemented problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#implemented-islands">Implemented islands</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#implemented-batch-evaluators">Implemented batch evaluators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#implemented-topologies">Implemented topologies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#implemented-replacement-policies">Implemented replacement policies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#implemented-selection-policies">Implemented selection policies</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../cpp_docs.html#utilities">Utilities</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Multi-objective optimization utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="constrained.html">Constrained optimization utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="discrepancy.html">Low-discrepancy sequences</a></li>
<li class="toctree-l3"><a class="reference internal" href="hypervolume.html">Hypervolumes</a></li>
<li class="toctree-l3"><a class="reference internal" href="gradient_and_hessians.html">Utilities for gradient and hessians</a></li>
<li class="toctree-l3"><a class="reference internal" href="genetic_operators.html">Genetic Operators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../cpp_docs.html#miscellanea">Miscellanea</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pagmo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../cpp_docs.html">C++ API documentation</a> &raquo;</li>
        
      <li>Multi-objective optimization utilities</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/docs/cpp/utils/multi_objective.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="multi-objective-optimization-utilities">
<span id="cpp-multi-objective-utils"></span><h1>Multi-objective optimization utilities<a class="headerlink" href="#multi-objective-optimization-utilities" title="Permalink to this headline">¶</a></h1>
<p>A number of utilities to compute quantities that are of relevance to
the determination of non dominated fronts, Pareto dominance criterias and
more in general, to multi-objective optimization tasks.</p>
<hr class="docutils" />
<dl class="cpp function">
<dt id="_CPPv4N5pagmo16pareto_dominanceERK13vector_doubleRK13vector_double">
<span id="_CPPv3N5pagmo16pareto_dominanceERK13vector_doubleRK13vector_double"></span><span id="_CPPv2N5pagmo16pareto_dominanceERK13vector_doubleRK13vector_double"></span><span id="pagmo::pareto_dominance__vector_doubleCR.vector_doubleCR"></span><span class="target" id="namespacepagmo_1ab72c593724e2370b7ee4f8a9828e5984"></span>bool <code class="sig-prename descclassname">pagmo<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">pareto_dominance</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> &amp;<em>obj1</em>, <em class="property">const</em> <a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> &amp;<em>obj2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5pagmo16pareto_dominanceERK13vector_doubleRK13vector_double" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Pareto-dominance. </p>
<p>Return true if <code class="docutils literal notranslate"><span class="pre">obj1</span></code> Pareto dominates <code class="docutils literal notranslate"><span class="pre">obj2</span></code>, false otherwise. Minimization is assumed.</p>
<p>Each pair of corresponding elements in <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is compared: if all elements in <code class="docutils literal notranslate"><span class="pre">obj1</span></code> are less or equal to the corresponding element in <code class="docutils literal notranslate"><span class="pre">obj2</span></code>, but at least one is different, <code class="docutils literal notranslate"><span class="pre">true</span></code> will be returned. Otherwise, <code class="docutils literal notranslate"><span class="pre">false</span></code> will be returned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">obj1</span></code> is dominating <code class="docutils literal notranslate"><span class="pre">obj2</span></code>, <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1</span></code>: first vector of objectives. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">obj2</span></code>: second vector of objectives.</p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::invalid_argument</span></code>: if the dimensions of the two objectives are different </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="cpp function">
<dt id="_CPPv4N5pagmo22non_dominated_front_2dERKNSt6vectorI13vector_doubleEE">
<span id="_CPPv3N5pagmo22non_dominated_front_2dERKNSt6vectorI13vector_doubleEE"></span><span id="_CPPv2N5pagmo22non_dominated_front_2dERKNSt6vectorI13vector_doubleEE"></span><span id="pagmo::non_dominated_front_2d__std::vector:vector_double:CR"></span><span class="target" id="namespacepagmo_1ab69bfac9d266e39e07ad959f9d16eb2a"></span>std::vector&lt;<a class="reference internal" href="../types.html#_CPPv4N5pagmo10pop_size_tE" title="pagmo::pop_size_t">pop_size_t</a>&gt; <code class="sig-prename descclassname">pagmo<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">non_dominated_front_2d</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>input_objs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5pagmo22non_dominated_front_2dERKNSt6vectorI13vector_doubleEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Non dominated front 2D (Kung’s algorithm) </p>
<p>Finds the non dominated front of a set of two dimensional objectives. Complexity is O(N logN) and is thus lower than the complexity of calling <a class="reference internal" href="#namespacepagmo_1a27aeb5efb01fca4422fc124eec221199"><span class="std std-ref">pagmo::fast_non_dominated_sorting</span></a></p>
<p>See: Jensen, Mikkel T. “Reducing the run-time complexity of multiobjective EAs: The NSGA-II and other algorithms.” IEEE Transactions on Evolutionary Computation 7.5 (2003): 503-515.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> containing the indexes of the points in the non-dominated front</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">input_objs</span></code>: an <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> containing the points (i.e. vector of objectives)</p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::invalid_argument</span></code>: If the objective vectors are not all containing two-objectives </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="cpp function">
<dt id="_CPPv4N5pagmo17crowding_distanceERKNSt6vectorI13vector_doubleEE">
<span id="_CPPv3N5pagmo17crowding_distanceERKNSt6vectorI13vector_doubleEE"></span><span id="_CPPv2N5pagmo17crowding_distanceERKNSt6vectorI13vector_doubleEE"></span><span id="pagmo::crowding_distance__std::vector:vector_double:CR"></span><span class="target" id="namespacepagmo_1ad503682786287cfe57f565e335524633"></span><a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> <code class="sig-prename descclassname">pagmo<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">crowding_distance</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>non_dom_front</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5pagmo17crowding_distanceERKNSt6vectorI13vector_doubleEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Crowding distance. </p>
<p>An implementation of the crowding distance. Complexity is <span class="math notranslate nohighlight">\( O(MNlog(N))\)</span> where <span class="math notranslate nohighlight">\(M\)</span> is the number of objectives and <span class="math notranslate nohighlight">\(N\)</span> is the number of individuals. The function assumes the input is a non-dominated front. Failiure to this condition will result in undefined behaviour.</p>
<p><p>See: Deb, Kalyanmoy, et al. “A fast elitist non-dominated sorting genetic algorithm</p>
<p>for multi-objective optimization: NSGA-II.” Parallel problem solving from nature PPSN VI. Springer Berlin Heidelberg, 2000.</p>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a vector_double containing the crowding distances. Example: {2, inf, inf}</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">non_dom_front</span></code>: An <code class="docutils literal notranslate"><span class="pre">std::vector&lt;vector_double&gt;</span></code> containing a non dominated front. Example {{0,0},{-1,1},{2,-2}}</p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::invalid_argument</span></code>: If <code class="docutils literal notranslate"><span class="pre">non_dom_front</span></code> does not contain at least two points </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::invalid_argument</span></code>: If points in <code class="docutils literal notranslate"><span class="pre">do</span></code> not all have at least two objectives </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::invalid_argument</span></code>: If points in <code class="docutils literal notranslate"><span class="pre">non_dom_front</span></code> do not all have the same dimensionality </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="cpp function">
<dt id="_CPPv4N5pagmo26fast_non_dominated_sortingERKNSt6vectorI13vector_doubleEE">
<span id="_CPPv3N5pagmo26fast_non_dominated_sortingERKNSt6vectorI13vector_doubleEE"></span><span id="_CPPv2N5pagmo26fast_non_dominated_sortingERKNSt6vectorI13vector_doubleEE"></span><span id="pagmo::fast_non_dominated_sorting__std::vector:vector_double:CR"></span><span class="target" id="namespacepagmo_1a27aeb5efb01fca4422fc124eec221199"></span>fnds_return_type <code class="sig-prename descclassname">pagmo<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">fast_non_dominated_sorting</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5pagmo26fast_non_dominated_sortingERKNSt6vectorI13vector_doubleEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Fast non dominated sorting. </p>
<p>An implementation of the fast non dominated sorting algorithm. Complexity is <span class="math notranslate nohighlight">\( O(MN^2)\)</span> where <span class="math notranslate nohighlight">\(M\)</span> is the number of objectives and <span class="math notranslate nohighlight">\(N\)</span> is the number of individuals.</p>
<p><p>See: Deb, Kalyanmoy, et al. “A fast elitist non-dominated sorting genetic algorithm</p>
<p>for multi-objective optimization: NSGA-II.” Parallel problem solving from nature PPSN VI. Springer Berlin Heidelberg, 2000.</p>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an std::tuple containing:<ul class="simple">
<li><p>the non dominated fronts, an <code class="docutils literal notranslate"><span class="pre">std::vector&lt;std::vector&lt;pop_size_t&gt;&gt;</span></code> containing the non dominated fronts. Example {{1,2},{3},{0}}</p></li>
<li><p>the domination list, an <code class="docutils literal notranslate"><span class="pre">std::vector&lt;std::vector&lt;pop_size_t&gt;&gt;</span></code> containing the domination list, i.e. the indexes of all individuals dominated by the individual at position <span class="math notranslate nohighlight">\(i\)</span>. Example {{},{},{0,3},{0}}</p></li>
<li><p>the domination count, an <code class="docutils literal notranslate"><span class="pre">std::vector&lt;pop_size_t&gt;</span></code> containing the number of individuals that dominate the individual at position <span class="math notranslate nohighlight">\(i\)</span>. Example {2, 0, 0, 1}</p></li>
<li><p>the non domination rank, an <code class="docutils literal notranslate"><span class="pre">std::vector&lt;pop_size_t&gt;</span></code> containing the index of the non dominated front to which the individual at position <span class="math notranslate nohighlight">\(i\)</span> belongs. Example {2,0,0,1}</p></li>
</ul>
</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">points</span></code>: An std::vector containing the objectives of different individuals. Example {{1,2,3},{-2,3,7},{-1,-2,-3},{0,0,0}}</p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::invalid_argument</span></code>: If the size of <code class="docutils literal notranslate"><span class="pre">points</span></code> is not at least 2 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="cpp function">
<dt id="_CPPv4N5pagmo18sort_population_moERKNSt6vectorI13vector_doubleEE">
<span id="_CPPv3N5pagmo18sort_population_moERKNSt6vectorI13vector_doubleEE"></span><span id="_CPPv2N5pagmo18sort_population_moERKNSt6vectorI13vector_doubleEE"></span><span id="pagmo::sort_population_mo__std::vector:vector_double:CR"></span><span class="target" id="namespacepagmo_1a580b5f4b60c15b204d79240140f4190f"></span>std::vector&lt;<a class="reference internal" href="../types.html#_CPPv4N5pagmo10pop_size_tE" title="pagmo::pop_size_t">pop_size_t</a>&gt; <code class="sig-prename descclassname">pagmo<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">sort_population_mo</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>input_f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5pagmo18sort_population_moERKNSt6vectorI13vector_doubleEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sorts a population in multi-objective optimization. </p>
<p>Sorts a population (intended here as an <code class="docutils literal notranslate"><span class="pre">std::vector&lt;vector_double&gt;</span></code> containing the objective vectors) with respect to the following strict ordering:<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(f_1 \prec f_2\)</span> if the non domination ranks are such that <span class="math notranslate nohighlight">\(i_1 &lt; i_2\)</span>. In case <span class="math notranslate nohighlight">\(i_1 = i_2\)</span>, then <span class="math notranslate nohighlight">\(f_1 \prec f_2\)</span> if the crowding distances are such that <span class="math notranslate nohighlight">\(d_1 &gt; d_2\)</span>.</p></li>
</ul>
</p>
<p>Complexity is <span class="math notranslate nohighlight">\( O(MN^2)\)</span> where <span class="math notranslate nohighlight">\(M\)</span> is the number of objectives and <span class="math notranslate nohighlight">\(N\)</span> is the number of individuals.</p>
<p>This function will also work for single objective optimization, i.e. with 1 objective in which case, though, it is more efficient to sort using directly one of the following forms:</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="p">::</span><span class="n">sort</span><span class="p">(</span><span class="n">input_f</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input_f</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="n">auto</span> <span class="n">a</span><span class="p">,</span> <span class="n">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];});</span>
</pre></div>
</div>
 <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pop_size_t</span><span class="o">&gt;</span> <span class="n">idx</span><span class="p">(</span><span class="n">input_f</span><span class="o">.</span><span class="n">size</span><span class="p">());</span>
<span class="n">std</span><span class="p">::</span><span class="n">iota</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">idx</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">pop_size_t</span><span class="p">(</span><span class="mi">0</span><span class="n">u</span><span class="p">));</span>
<span class="n">std</span><span class="p">::</span><span class="n">sort</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">idx</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="n">auto</span> <span class="n">a</span><span class="p">,</span> <span class="n">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">input_f</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">input_f</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">0</span><span class="p">];});</span>
</pre></div>
</div>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> containing the indexes of the sorted objectives vectors. Example {1,2,0}</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">input_f</span></code>: Input objectives vectors. Example {{0.25,0.25},{-1,1},{2,-2}};</p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">unspecified</span></code>: all exceptions thrown by <a class="reference internal" href="#namespacepagmo_1a27aeb5efb01fca4422fc124eec221199"><span class="std std-ref">pagmo::fast_non_dominated_sorting</span></a> and <a class="reference internal" href="#namespacepagmo_1ad503682786287cfe57f565e335524633"><span class="std std-ref">pagmo::crowding_distance</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="cpp function">
<dt id="_CPPv4N5pagmo16select_best_N_moERKNSt6vectorI13vector_doubleEE10pop_size_t">
<span id="_CPPv3N5pagmo16select_best_N_moERKNSt6vectorI13vector_doubleEE10pop_size_t"></span><span id="_CPPv2N5pagmo16select_best_N_moERKNSt6vectorI13vector_doubleEE10pop_size_t"></span><span id="pagmo::select_best_N_mo__std::vector:vector_double:CR.pop_size_t"></span><span class="target" id="namespacepagmo_1a28e3bb8bec5b0c936d416383c417cf99"></span>std::vector&lt;<a class="reference internal" href="../types.html#_CPPv4N5pagmo10pop_size_tE" title="pagmo::pop_size_t">pop_size_t</a>&gt; <code class="sig-prename descclassname">pagmo<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">select_best_N_mo</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>input_f</em>, <a class="reference internal" href="../types.html#_CPPv4N5pagmo10pop_size_tE" title="pagmo::pop_size_t">pop_size_t</a> <em>N</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5pagmo16select_best_N_moERKNSt6vectorI13vector_doubleEE10pop_size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Selects the best N individuals in multi-objective optimization. </p>
<p>Selects the best N individuals out of a population, (intended here as an <code class="docutils literal notranslate"><span class="pre">std::vector&lt;vector_double&gt;</span></code> containing the objective vectors). The strict ordering used is the same as that defined in <a class="reference internal" href="#namespacepagmo_1a580b5f4b60c15b204d79240140f4190f"><span class="std std-ref">pagmo::sort_population_mo</span></a>.</p>
<p>Complexity is <span class="math notranslate nohighlight">\( O(MN^2)\)</span> where <span class="math notranslate nohighlight">\(M\)</span> is the number of objectives and <span class="math notranslate nohighlight">\(N\)</span> is the number of individuals.</p>
<p>While the complexity is the same as that of <a class="reference internal" href="#namespacepagmo_1a580b5f4b60c15b204d79240140f4190f"><span class="std std-ref">pagmo::sort_population_mo</span></a>, this function returns a permutation of:</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pagmo</span><span class="p">::</span><span class="n">sort_population_mo</span><span class="p">(</span><span class="n">input_f</span><span class="p">)</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p>but it is faster than the above code: it avoids to compute the crowidng distance for all individuals and only computes it for the last non-dominated front that contains individuals included in the best N.</p>
<p>If N is zero, an empty vector will be returned.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> containing the indexes of the best N objective vectors. Example {2,1}</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">input_f</span></code>: Input objectives vectors. Example {{0.25,0.25},{-1,1},{2,-2}}; </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">N</span></code>: Number of best individuals to return</p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">unspecified</span></code>: all exceptions thrown by <a class="reference internal" href="#namespacepagmo_1a27aeb5efb01fca4422fc124eec221199"><span class="std std-ref">pagmo::fast_non_dominated_sorting</span></a> and <a class="reference internal" href="#namespacepagmo_1ad503682786287cfe57f565e335524633"><span class="std std-ref">pagmo::crowding_distance</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="cpp function">
<dt id="_CPPv4N5pagmo5idealERKNSt6vectorI13vector_doubleEE">
<span id="_CPPv3N5pagmo5idealERKNSt6vectorI13vector_doubleEE"></span><span id="_CPPv2N5pagmo5idealERKNSt6vectorI13vector_doubleEE"></span><span id="pagmo::ideal__std::vector:vector_double:CR"></span><span class="target" id="namespacepagmo_1a03f1dbeb382df95af4ac18c4db64c139"></span><a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> <code class="sig-prename descclassname">pagmo<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">ideal</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5pagmo5idealERKNSt6vectorI13vector_doubleEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Ideal point. </p>
<p>Computes the ideal point of an input population, (intended here as an <code class="docutils literal notranslate"><span class="pre">std::vector&lt;vector_double&gt;</span></code> containing the objective vectors).</p>
<p>Complexity is <span class="math notranslate nohighlight">\( O(MN)\)</span> where <span class="math notranslate nohighlight">\(M\)</span> is the number of objectives and <span class="math notranslate nohighlight">\(N\)</span> is the number of individuals.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A vector_double containing the ideal point. Example: {-1,-2,231}</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">points</span></code>: Input objectives vectors. Example {{-1,3,597},{1,2,3645},{2,9,789},{0,0,231},{6,-2,4576}};</p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::invalid_argument</span></code>: if the input objective vectors are not all of the same size </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="cpp function">
<dt id="_CPPv4N5pagmo5nadirERKNSt6vectorI13vector_doubleEE">
<span id="_CPPv3N5pagmo5nadirERKNSt6vectorI13vector_doubleEE"></span><span id="_CPPv2N5pagmo5nadirERKNSt6vectorI13vector_doubleEE"></span><span id="pagmo::nadir__std::vector:vector_double:CR"></span><span class="target" id="namespacepagmo_1a88a611f76187a58dcdcfb813ef4ffcb9"></span><a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> <code class="sig-prename descclassname">pagmo<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">nadir</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; &amp;<em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5pagmo5nadirERKNSt6vectorI13vector_doubleEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Nadir point. </p>
<p>Computes the nadir point of an input population, (intended here as an <code class="docutils literal notranslate"><span class="pre">std::vector&lt;vector_double&gt;</span></code> containing the objective vectors).</p>
<p>Complexity is <span class="math notranslate nohighlight">\( O(MN^2)\)</span> where <span class="math notranslate nohighlight">\(M\)</span> is the number of objectives and <span class="math notranslate nohighlight">\(N\)</span> is the number of individuals.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>A vector_double containing the nadir point. Example: {10,7} </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">points</span></code>: Input objective vectors. Example {{0,7},{1,5},{2,3},{4,2},{7,1},{10,0},{6,6},{9,15}}</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="cpp function">
<dt id="_CPPv4I0EN5pagmo21decomposition_weightsENSt6vectorI13vector_doubleEEN13vector_double9size_typeEN13vector_double9size_typeERKNSt6stringER3Rng">
<span id="_CPPv3I0EN5pagmo21decomposition_weightsEN13vector_double9size_typeEN13vector_double9size_typeERKNSt6stringER3Rng"></span><span id="_CPPv2I0EN5pagmo21decomposition_weightsEN13vector_double9size_typeEN13vector_double9size_typeERKNSt6stringER3Rng"></span>template&lt;typename <code class="sig-name descname">Rng</code>&gt;<br /><span class="target" id="namespacepagmo_1a894b3b3929be6f212b466e889035d2a2"></span>std::vector&lt;<a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>&gt; <code class="sig-prename descclassname">pagmo<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">decomposition_weights</code><span class="sig-paren">(</span><a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>::size_type <em>n_f</em>, <a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a>::size_type <em>n_w</em>, <em class="property">const</em> std::string &amp;<em>method</em>, <a class="reference internal" href="#_CPPv4I0EN5pagmo21decomposition_weightsENSt6vectorI13vector_doubleEEN13vector_double9size_typeEN13vector_double9size_typeERKNSt6stringER3Rng" title="pagmo::decomposition_weights::Rng">Rng</a> &amp;<em>r_engine</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5pagmo21decomposition_weightsENSt6vectorI13vector_doubleEEN13vector_double9size_typeEN13vector_double9size_typeERKNSt6stringER3Rng" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Decomposition weights generation. </p>
<p>Generates a requested number of weight vectors to be used to decompose a multi-objective problem. Three methods are available:<ul class="simple">
<li><p>”grid” generates weights on an uniform grid. This method may only be used when the number of requested weights to be genrated is such that a uniform grid is indeed possible. In two dimensions this is always the case, but in larger dimensions uniform grids are possible only in special cases</p></li>
<li><p>”random” generates weights randomly distributing them uniformly on the simplex (weights are such that <span class="math notranslate nohighlight">\(\sum_i \lambda_i = 1\)</span>)</p></li>
<li><p>”low discrepancy” generates weights using a low-discrepancy sequence to, eventually, obtain a better coverage of the Pareto front. Halton sequence is used since low dimensionalities are expected in the number of objectives (i.e. less than 20), hence Halton sequence is deemed as appropriate.</p></li>
</ul>
</p>
<p><p><div class="admonition note">
<p class="admonition-title">Note</p>
<p>All genration methods are guaranteed to generate weights on the simplex (<span class="math notranslate nohighlight">\(\sum_i \lambda_i = 1\)</span>). All
weight generation methods are guaranteed to generate the canonical weights [1,0,0,…], [0,1,0,..], … first.</p>
</div>
</p>
</p>
<p>Example: to generate 10 weights distributed somewhat regularly to decompose a three dimensional problem: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="p">::</span><span class="n">mt19937</span> <span class="n">r_engine</span><span class="p">;</span>
<span class="n">auto</span> <span class="n">lambdas</span> <span class="o">=</span> <span class="n">decomposition_weights</span><span class="p">(</span><span class="mi">3</span><span class="n">u</span><span class="p">,</span> <span class="mi">10</span><span class="n">u</span><span class="p">,</span> <span class="s2">&quot;low discrepancy&quot;</span><span class="p">,</span> <span class="n">r_engine</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an <code class="docutils literal notranslate"><span class="pre">std:vector</span></code> containing the weight vectors</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n_f</span></code>: dimension of each weight vector (i.e. fitness dimension) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n_w</span></code>: number of weights to be generated </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code>: methods to generate the weights of the decomposed problems. One of “grid”, “random”, “low discrepancy” </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">r_engine</span></code>: a C++ random engine</p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">if</span></code>: <code class="docutils literal notranslate"><span class="pre">nf</span></code> and <code class="docutils literal notranslate"><span class="pre">nw</span></code> are not compatible with the selected weight generation method or if <code class="docutils literal notranslate"><span class="pre">method</span></code> is not one of “grid”, “random” or “low discrepancy” </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<hr class="docutils" />
<dl class="cpp function">
<dt id="_CPPv4N5pagmo20decompose_objectivesERK13vector_doubleRK13vector_doubleRK13vector_doubleRKNSt6stringE">
<span id="_CPPv3N5pagmo20decompose_objectivesERK13vector_doubleRK13vector_doubleRK13vector_doubleRKNSt6stringE"></span><span id="_CPPv2N5pagmo20decompose_objectivesERK13vector_doubleRK13vector_doubleRK13vector_doubleRKNSt6stringE"></span><span id="pagmo::decompose_objectives__vector_doubleCR.vector_doubleCR.vector_doubleCR.ssCR"></span><span class="target" id="namespacepagmo_1ab619aca81b1ad186aab7f3b67418954b"></span><a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> <code class="sig-prename descclassname">pagmo<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">decompose_objectives</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> &amp;<em>f</em>, <em class="property">const</em> <a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> &amp;<em>weight</em>, <em class="property">const</em> <a class="reference internal" href="../types.html#_CPPv4N5pagmo13vector_doubleE" title="pagmo::vector_double">vector_double</a> &amp;<em>ref_point</em>, <em class="property">const</em> std::string &amp;<em>method</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5pagmo20decompose_objectivesERK13vector_doubleRK13vector_doubleRK13vector_doubleRKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Decomposes a vector of objectives. </p>
<p>A vector of objectives is reduced to one only objective using a decomposition technique.</p>
<p>Three different <em>decomposition methods</em> are here made available:</p>
<p><ul class="simple">
<li><p>weighted decomposition,</p></li>
<li><p>Tchebycheff decomposition,</p></li>
<li><p>boundary interception method (with penalty constraint).</p></li>
</ul>
</p>
<p>In the case of <span class="math notranslate nohighlight">\(n\)</span> objectives, we indicate with: <span class="math notranslate nohighlight">\( \mathbf f(\mathbf x) = [f_1(\mathbf x), \ldots, f_n(\mathbf x)] \)</span> the vector containing the original multiple objectives, with: <span class="math notranslate nohighlight">\( \boldsymbol \lambda = (\lambda_1, \ldots, \lambda_n) \)</span> an <span class="math notranslate nohighlight">\(n\)</span>-dimensional weight vector and with: <span class="math notranslate nohighlight">\( \mathbf z^* = (z^*_1, \ldots, z^*_n) \)</span> an <span class="math notranslate nohighlight">\(n\)</span>-dimensional reference point. We also ussume <span class="math notranslate nohighlight">\(\lambda_i &gt; 0, \forall i=1..n\)</span> and <span class="math notranslate nohighlight">\(\sum_i \lambda_i = 1\)</span>.</p>
<p>The resulting single objective is thus defined as:</p>
<p><ul class="simple">
<li><p>weighted decomposition: <span class="math notranslate nohighlight">\( f_d(\mathbf x) = \boldsymbol \lambda \cdot \mathbf f \)</span>,</p></li>
<li><p>Tchebycheff decomposition: <span class="math notranslate nohighlight">\( f_d(\mathbf x) = \max_{1 \leq i \leq m} \lambda_i \vert f_i(\mathbf x) - z^*_i \vert \)</span>,</p></li>
<li><p>boundary interception method (with penalty constraint): <span class="math notranslate nohighlight">\( f_d(\mathbf x) = d_1 + \theta d_2\)</span>,</p></li>
</ul>
</p>
<p>where <span class="math notranslate nohighlight">\(d_1 = (\mathbf f - \mathbf z^*) \cdot \hat {\mathbf i}_{\lambda}\)</span>, <span class="math notranslate nohighlight">\(d_2 = \vert (\mathbf f - \mathbf z^*) - d_1 \hat {\mathbf i}_{\lambda})\vert\)</span> and <span class="math notranslate nohighlight">\( \hat {\mathbf i}_{\lambda} = \frac{\boldsymbol \lambda}{\vert \boldsymbol \lambda \vert}\)</span>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the decomposed objective.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code>: input vector of objectives. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight</span></code>: the weight to be used in the decomposition. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ref_point</span></code>: the reference point to be used if either “tchebycheff” or “bi”. was indicated as a decomposition method. Its value is ignored if “weighted” was indicated. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code>: decomposition method: one of “weighted”, “tchebycheff” or “bi”</p></li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">std::invalid_argument</span></code>: if <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">weight</span></code> and <code class="docutils literal notranslate"><span class="pre">ref_point</span></code> have different sizes </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::invalid_argument</span></code>: if <code class="docutils literal notranslate"><span class="pre">method</span></code> is not one of “weighted”, “tchebycheff” or “bi” </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="constrained.html" class="btn btn-neutral float-right" title="Constrained optimization utilities" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../s_policies/select_best.html" class="btn btn-neutral float-left" title="Best selection policy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017-2020, pagmo development team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>